#!/usr/bin/env python
# coding: utf-8

# # Лабораторная работа 4. Изучение регулярных выражений и их использование

# Очень часто при обработке текстовых данных возникает задача о сопоставлении строки с образцом. Самый простой пример — проверка корректности вводимых пользователем данных. Допустим, у нас имеются следующие требования к паролю, используемому в системе:
# 
# * пароль должен иметь длину не меньше 6 символов, но не больше 15;
# * пароль может содержать как строчные, так и прописные буквы, а также цифры;
# * пароль должен начинаться с заглавной буквы, а заканчиваться строчной буквой.
# 
# В принципе, можно написать функцию, которая будет проверять, соответствует ли строка предъявляемым требованиям:

# In[1]:


def check_password(s):
    if not 6 <= len(s) <= 15:
        return False
    if not 'A' <= s[0] <= 'Z':
        return False
    if not 'a' <= s[-1] <= 'z':
        return False
    for c in s[1:-1]:
        if not ('a' <= c <= 'z' or 'A' <= c <= 'Z' or '0' <= c <= '9'):
            return False
    return True


# А можно пойти другим путём и воспользоваться специально предназначенным для этого инструментом — регулярными выражениями:

# In[2]:


import re

def check_password_with_regexp(s):
    return re.match(r'^[A-Z]{1}[a-zA-Z0-9]{4,13}[a-z]{1}$', s)


# Как видно из примера, вид функции check_password сильно изменился. Мы не будем на данном этапе пытаться разобраться в том, как именно работает новая версия функции, а лишь отметим одно важное отличие: первая версия функции выполняла ряд проверок, пытаясь найти символ, не соответствующий предъявляемым требованиям, вторая же версия функции вместо этого выясняет, соответствует ли переданная строка заранее заданному образцу. Именно в этом и заключается основное предназначение регулярных выражений — они позволяют описать, как должна выглядеть строка, если она удовлетворяет определённым критериям.

# ### Модуль `re` стандартной библиотеки языка Python предоставляет набор функций и классов для работы с регулярными выражениями. Вот список наиболее часто используемых из них:
# 
# https://docs.python.org/3/library/re.html
# 
+----------------+----------------------------------------------------------------------------------------------------------+
| Функция        | Описание                                                                                                 |
+================+==========================================================================================================+
| `re.match`__   | Ищет соответствие заданному шаблону в начале строки                                                      |
+----------------+----------------------------------------------------------------------------------------------------------+
| `re.search`__  | Ищет соответствие заданному шаблону в произвольном месте строки и возвращает первое найденное совпадение |
+----------------+----------------------------------------------------------------------------------------------------------+
| `re.findall`__ | Находит и возвращает список всех непересекающихся подстрок исходной строки, соответствующих шаблону      |
+----------------+----------------------------------------------------------------------------------------------------------+
| `re.split`__   | Разбивает строку на набор подстрок с использованием шаблона для поиска разделителей                      |
+----------------+----------------------------------------------------------------------------------------------------------+
| `re.sub`__     | Заменяет подстроку, соответствующую шаблону, указанным значением                                         |
+----------------+----------------------------------------------------------------------------------------------------------+
| `re.compile`__ | «Компилирует» регулярное выражение для дальнейшего использования                                         |
+----------------+----------------------------------------------------------------------------------------------------------+
# Теперь рассмотрим несколько примеров работы с регулярными выражениями. Пока что мы не знаем синтаксиса, используемого для описания регулярных выражений, поэтому рассмотрим самый простой случай: когда в качестве регулярного выражения выступает непосредственно искомая строка.

# In[3]:


import re

s = 'с самого начала у меня была какая-то тактика, и я её придерживался'

re.match('с самого', s)


# In[4]:


re.match('была', s)
re.search('была', s)


# In[5]:


re.findall('и', s)


# In[6]:


re.split(' ', s)


# In[7]:


re.split(',', s)
re.sub('придерживался', 'использовал', s)


# In[8]:


regexp = re.compile('с самого')
regexp.match(s)


# Как видно из примера, функции re.match и re.search возвращают в случает совпадения экземпляр класса SRE_Match или None, если совпадение не найдено, в то время как функции re.findall, re.split возвращают список, состоящий из строк, функция re.sub возвращает строку, получающуюся после выполнения замены.

# ### Базовый синтаксис
# 
# В предыдущих примерах мы использовали искомую строку в качестве регулярного выражения. Теперь настало время
# познакомиться более подробно с синтаксисом описания регулярных выражений.
# 
# Помимо непосредственно искомых символов регулярное выражение может содержать специальные символы, которые позволяют
# задать **шаблон**. Вот краткий список основных из них:
+---------------------+----------------------------------------------------------+
| Специальные символы | Описание                                                 |
+=====================+==========================================================+
| .                   | Любой символ, кроме символа новой строки                 |
+---------------------+----------------------------------------------------------+
| ^                   | Начало строки                                            |
+---------------------+----------------------------------------------------------+
| $                   | Конец строки                                             |
+---------------------+----------------------------------------------------------+
| ?                   | 0 или 1 соответствие шаблона слева                       |
+---------------------+----------------------------------------------------------+
| \*                  | 0 или больше соответствий шаблона слева                  |
+---------------------+----------------------------------------------------------+
| \+                  | 1 или более соответствий шаблона слева                   |
+---------------------+----------------------------------------------------------+
| {m}                 | Ровно m соответствий шаблона слева                       |
+---------------------+----------------------------------------------------------+
| {m,n}               | Не меньше m, но и не больше n соответствий шаблона слева |
+---------------------+----------------------------------------------------------+
| \\                  | Экранирование служебных символов                         |
+---------------------+----------------------------------------------------------+
| [abc]               | Любой из символов a, b, c                                |
+---------------------+----------------------------------------------------------+
| [^abc]              | Любой символ, кроме a, b, c                              |
+---------------------+----------------------------------------------------------+
| [0-5]               | Любой из символов 0, 1, 2, 3, 4, 5                       |
+---------------------+----------------------------------------------------------+
| [a-d]               | Любой из символов a, b, c, d                             |
+---------------------+----------------------------------------------------------+
| a\|b                | a или b                                                  |
+---------------------+----------------------------------------------------------+


# ## Задание 1. 
# Обратите внимание, что в файле указано ожидаемое поведение программы для конкретного набора строк, а не чёткая формулировка задания наподобие «напишите регулярное выражение, соответствующее строке, состоящей только из прописных букв». Это сделано сознательно: дело в том, что при помощи регулярных выражений обычно решают некую вполне конкретную задачу, а не какую-то абстрактную общую задачу. И поэтому во многих задачах из этой работы возможно более одного правильного решения. Например, строка ABabAB соответствует как регулярному выражению [ABab]+, так и выражению ^A.*B$, да и ещё достаточно большому количеству других выражений.

# В файл simple_match.py впишите требуемые регулярные выражения REGEXP_1, REGEXP_2 и т.д., после чего запустите на выполнение тесты из файла simple_match_test.py. Добейтесь прохождения всех тестов.
# 
# Обратите внимание, что в файле указано ожидаемое поведение программы для конкретного набора строк, а не чёткая формулировка задания наподобие «напишите регулярное выражение, соответствующее строке, состоящей только из прописных букв». Это сделано сознательно: дело в том, что при помощи регулярных выражений обычно решают некую вполне конкретную задачу, а не какую-то абстрактную общую задачу. И поэтому во многих задачах из этой работы возможно более одного правильного решения. Например, строка ABabAB соответствует как регулярному выражению [ABab]+, так и выражению ^A.*B$, да и ещё достаточно большому количеству других выражений.

# In[9]:


get_ipython().run_line_magic('run', 'simple_match_test.py')


# ## Задание 2. 
# Теперь перейдём к рассмотрению более сложных специальных символов, поддержка которых присутствует в библиотеке re. Эти символы нужны как для написания сложных, так и для сокращения длинных регулярных выражений. Неполный список специальных символов приведён в таблице ниже:
+--------------------+-----------------------------------------------------------+
| Специальный символ | Описание                                                  |
+====================+===========================================================+
| \A                | Начало строки; эквивалент ^                               |
+--------------------+-----------------------------------------------------------+
| \b                | Начало слова                                              |
+--------------------+-----------------------------------------------------------+
| \B                | **Не** начало слова                                       |
+--------------------+-----------------------------------------------------------+
| \d                | Цифра; расширенный вариант [0-9]                          |
+--------------------+-----------------------------------------------------------+
| \D                | **Не** цифра; «отрицание» \d                             |
+--------------------+-----------------------------------------------------------+
| \s                | Пробельный символ; расширенный вариант [ \t\n\r\f\v] |
+--------------------+-----------------------------------------------------------+
| \S                | **Не** пробельный символ; «отрицание» \s                 |
+--------------------+-----------------------------------------------------------+
| \w                | «Буква» в слове расширенный вариант [a-zA-Z0-9\_]         |
+--------------------+-----------------------------------------------------------+
| \W                | **Не** «буква»; «отрицание» \w                           |
+--------------------+-----------------------------------------------------------+
| \Z                | Конец строки; эквивалент $                                |
+--------------------+-----------------------------------------------------------+

Приведем несколько примеров
# In[10]:


import re
re.match(r'\Aab', 'abcd')


# In[11]:


re.match(r'\Aab', 'dabcd')
re.search(r'\bbbb', 'abbba bbb ccc')


# In[12]:


re.search(r'\Bbbb', 'abbba bbb ccc')


# In[13]:


re.search(r'\d+', 'ab123cd')


# In[14]:


re.search(r'\D+', 'ab123cd')


# In[15]:


re.sub(r'\s+', '_', 'aa bb cc dd')


# In[16]:


re.findall(r'\S+', 'aa bb cc dd')


# In[17]:


re.search(r'\w+', 'ab123cd')


# In[18]:


re.search(r'\W+', 'ab123cd')
re.search(r'\w+', 'ab123cd  aaa')


# In[19]:


re.search(r'\W+', 'ab123cd  aaa')


# In[20]:


re.search(r'aa\Z', 'bbaa')


# In[21]:


re.search(r'aa\Z', 'bbaab')


# В файл simple_search.py впишите требуемые регулярные выражения REGEXP_1, REGEXP_2 и т.д., после чего запустите на выполнение тесты из файла simple_search_test.py. Добейтесь прохождения всех тестов.

# In[22]:


get_ipython().run_line_magic('run', 'simple_search_test.py')


# In[ ]:





# In[ ]:




